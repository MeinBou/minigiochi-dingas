<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minigiochi Dingas (Online)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
        }
        .card-container { perspective: 1000px; }
        .card {
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s, opacity 0.5s;
            width: 100%;
            height: 100%;
        }
        .card.flipped { transform: rotateY(180deg); }
        .card.matched {
            transform: rotateY(180deg) scale(0);
            opacity: 0;
        }
        .card .front, .card .back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
        }
        .card .front { transform: rotateY(180deg); }
        .shake { animation: shake 0.5s; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .modal-backdrop { transition: opacity 0.3s ease-in-out; }

        /* Stili Bomba */
        .player-circle-item {
            transition: transform 0.3s, opacity 0.5s;
        }
        .player-circle-item.eliminated {
            transform: scale(0.8);
            opacity: 0;
            pointer-events: none;
        }
        .bomb-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .bomb {
            transition: transform 0.2s, color 0.5s;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            z-index: 10;
        }
        .bomb-timer-ring {
            position: absolute;
            border-radius: 50%;
            border: 10px solid;
            transition: width 0.1s linear, height 0.1s linear, border-color 0.5s;
        }
        .bomb-unstable-1 { animation: mild-shake 0.5s infinite; color: #fef08a; } /* Giallo */
        .bomb-unstable-2 { animation: moderate-shake 0.3s infinite; color: #fb923c; } /* Arancione */
        .bomb-unstable-3 { animation: intense-shake 0.1s infinite; color: #ef4444; } /* Rosso */
        .explosion {
            animation: explosion-anim 0.5s forwards;
            font-weight: 900;
            color: #fef08a;
            text-shadow: 0 0 5px #fef08a, 0 0 15px #ef4444, 0 0 30px #ef4444;
        }

        @keyframes mild-shake { 0%, 100% { transform: translate(1px, -1px) rotate(-1deg); } 50% { transform: translate(-1px, 1px) rotate(1deg); } }
        @keyframes moderate-shake { 0%, 100% { transform: translate(3px, -2px) rotate(2deg); } 50% { transform: translate(-3px, 2px) rotate(-2deg); } }
        @keyframes intense-shake { 0%, 100% { transform: translate(5px, -5px) rotate(4deg); } 50% { transform: translate(-5px, 5px) rotate(-4deg); } }
        @keyframes explosion-anim { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(5); opacity: 0; } }
    </style>
</head>
<body class="bg-slate-900 text-white flex items-center justify-center min-h-screen p-2 sm:p-4">

    <div id="game-container" class="w-full max-w-5xl mx-auto">

        <!-- Schermata Nickname -->
        <div id="nickname-screen" class="text-center bg-slate-800 p-8 rounded-xl shadow-2xl">
            <h1 class="text-4xl font-bold mb-2 text-cyan-400">Benvenuto a Minigiochi Dingas!</h1>
            <p class="text-slate-400 mb-6">Scegli il tuo nickname per iniziare.</p>
            <input type="text" id="nickname-input" placeholder="Il tuo nickname..." class="w-full max-w-sm mx-auto bg-slate-700 text-white p-3 rounded-lg border-2 border-slate-600 focus:border-cyan-400 focus:outline-none">
            <button id="join-lobby-btn" class="mt-4 w-full max-w-sm mx-auto bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">Entra nella Lobby</button>
        </div>

        <!-- Schermata Lobby -->
        <div id="lobby-screen" class="hidden text-center bg-slate-800 p-8 rounded-xl shadow-2xl">
            <h2 class="text-3xl font-bold mb-6 text-cyan-400">Lobby</h2>
            <div class="flex flex-col md:flex-row gap-4 justify-center">
                <button id="create-room-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 flex-1">Crea Stanza</button>
                <div class="flex-1">
                    <input type="text" id="join-code-input" placeholder="Codice stanza..." class="w-full bg-slate-700 text-white p-3 rounded-lg border-2 border-slate-600 focus:border-green-400 focus:outline-none" disabled>
                    <button id="join-room-btn" class="mt-2 w-full bg-blue-500 text-white font-bold py-3 px-4 rounded-lg disabled:bg-slate-600 disabled:cursor-not-allowed" disabled>Unisciti (Disabilitato)</button>
                </div>
            </div>
        </div>
        
        <!-- Schermata Creazione Stanza (Host) -->
        <div id="create-room-screen" class="hidden text-center bg-slate-800 p-8 rounded-xl shadow-2xl">
            <h2 class="text-3xl font-bold mb-4 text-cyan-400">Configura la Stanza</h2>
            <div class="mb-6">
                <label for="player-count-slider" class="block mb-2 text-slate-300">Numero massimo di giocatori: <span id="player-count-value" class="font-bold text-cyan-400">8</span></label>
                <input id="player-count-slider" type="range" min="2" max="14" value="8" class="w-full max-w-sm mx-auto">
            </div>
             <div class="mb-6">
                <label for="cpu-difficulty-slider" class="block mb-2 text-slate-300">DifficoltÃ  CPU: <span id="cpu-difficulty-value" class="font-bold text-cyan-400">1</span></label>
                <input id="cpu-difficulty-slider" type="range" min="1" max="4" value="1" class="w-full max-w-sm mx-auto">
            </div>
            <div class="mb-6">
                <label for="rounds-count-slider" class="block mb-2 text-slate-300">Round Campionato: <span id="rounds-count-value" class="font-bold text-cyan-400">4</span></label>
                <input id="rounds-count-slider" type="range" min="4" max="8" value="4" class="w-full max-w-sm mx-auto">
            </div>
            <button id="confirm-create-room-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105">Conferma e Crea</button>
        </div>

        <!-- Sala d'attesa -->
        <div id="room-wait-screen" class="hidden bg-slate-800 p-8 rounded-xl shadow-2xl">
            <h2 class="text-3xl font-bold mb-2 text-cyan-400">Sala d'attesa</h2>
            <div class="mb-4 text-center">
                <p class="text-slate-400">Condividi questo codice con i tuoi amici:</p>
                <div class="bg-slate-900 p-3 rounded-lg mt-2 inline-block cursor-pointer" id="copy-room-code">
                    <span id="room-code-display" class="text-2xl font-mono tracking-widest text-green-400"></span>
                    <span id="copy-feedback" class="text-sm text-cyan-400 ml-2"></span>
                </div>
            </div>
            <h3 class="text-xl font-bold mb-4 text-center">Giocatori (<span id="current-players">1</span>/<span id="max-players">8</span>)</h3>
            <div id="player-list" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6"></div>
            <div id="host-controls" class="text-center hidden">
                <button id="add-cpu-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg mb-4">Aggiungi CPU</button>
                <button id="start-game-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg text-xl transition-transform transform hover:scale-105 disabled:bg-slate-600 disabled:cursor-not-allowed" disabled>Inizia Partita</button>
            </div>
        </div>
        
        <!-- Schermata Votazione ModalitÃ  -->
        <div id="game-mode-vote-screen" class="hidden text-center bg-slate-800 p-8 rounded-xl shadow-2xl">
            <h2 class="text-3xl font-bold mb-6 text-cyan-400">Scegli la modalitÃ  di gioco</h2>
            <p class="text-slate-400 mb-6">La modalitÃ  con piÃ¹ voti verrÃ  scelta.</p>
            <div id="vote-options" class="flex flex-col md:flex-row gap-4 justify-center">
                 <button data-vote="free-play" class="vote-btn bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-6 rounded-lg transition-transform transform hover:scale-105 flex-1">Partita Libera</button>
                 <button data-vote="championship" class="vote-btn bg-purple-500 hover:bg-purple-600 text-white font-bold py-4 px-6 rounded-lg transition-transform transform hover:scale-105 flex-1">Campionato</button>
            </div>
            <p id="vote-feedback" class="mt-4 text-slate-300 h-5"></p>
        </div>

        <!-- Schermata Gioco Memory -->
        <div id="memory-game-screen" class="hidden">
             <div class="flex flex-col lg:flex-row gap-4">
                 <div class="lg:w-1/4 bg-slate-800 p-4 rounded-xl shadow-lg order-2 lg:order-1 h-fit">
                     <h3 id="leaderboard-title" class="text-2xl font-bold mb-4 text-center text-cyan-400">Classifica</h3>
                     <div id="leaderboard" class="space-y-3"></div>
                 </div>
                 <div class="lg:w-3/4 order-1 lg:order-2">
                     <div id="game-info" class="text-center mb-4 p-3 bg-slate-800 rounded-xl">
                         <p id="game-mode-display" class="text-lg font-semibold text-purple-400"></p>
                         <p id="turn-indicator" class="text-xl">Turno di: <span id="current-player-turn" class="font-bold text-cyan-400"></span></p>
                     </div>
                     <div id="memory-board" class="grid gap-1 sm:gap-2 justify-center"></div>
                 </div>
             </div>
        </div>

        <!-- Schermata Gioco Bomba -->
        <div id="bomba-screen" class="hidden flex flex-col items-center justify-center bg-slate-800 p-4 rounded-xl shadow-2xl h-[85vh]">
            <div id="bomba-info" class="text-center mb-4"></div>
            <div id="player-circle" class="relative w-full max-w-lg aspect-square mb-4 flex items-center justify-center">
                <!-- Giocatori in cerchio e bomba generati da JS -->
            </div>
            <div id="pass-bomb-container" class="h-20">
                <button id="pass-bomb-btn" class="hidden bg-green-500 hover:bg-green-600 text-white font-black text-2xl py-4 px-10 rounded-full shadow-2xl transition-transform transform hover:scale-110">PASSA!</button>
            </div>
        </div>
        
        <!-- Schermata Riepilogo -->
        <div id="summary-screen" class="hidden text-center bg-slate-800 p-8 rounded-xl shadow-2xl">
            <h2 id="summary-title" class="text-4xl font-bold mb-4 text-cyan-400"></h2>
            <p id="summary-subtitle" class="text-slate-400 mb-6"></p>
            <div id="summary-leaderboard" class="w-full max-w-md mx-auto space-y-3"></div>
            <button id="play-again-btn" class="hidden mt-6 bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-6 rounded-lg text-lg">Gioca Ancora</button>
        </div>

        <!-- Schermata Selezione Minigioco -->
        <div id="minigame-selection-screen" class="hidden text-center bg-slate-800 p-8 rounded-xl shadow-2xl">
            <h2 class="text-3xl font-bold mb-6 text-cyan-400">Scegli un Minigioco (Host)</h2>
            <div id="minigame-options" class="flex flex-col gap-4 justify-center max-w-sm mx-auto">
                 <button data-minigame="memory" class="minigame-btn bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-6 rounded-lg transition-transform transform hover:scale-105">Memory</button>
                 <button data-minigame="bomba" class="minigame-btn bg-red-500 hover:bg-red-600 text-white font-bold py-4 px-6 rounded-lg transition-transform transform hover:scale-105">Bomba</button>
            </div>
             <p id="minigame-selection-wait-msg" class="hidden mt-4 text-slate-400">In attesa che l'host scelga il prossimo gioco...</p>
        </div>

    </div>
    
    <!-- Modal per notifiche -->
    <div id="notification-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 modal-backdrop z-50">
        <div class="bg-slate-800 rounded-xl shadow-2xl p-6 text-center max-w-sm mx-auto">
            <p id="modal-message" class="text-lg text-white mb-4"></p>
            <button id="modal-close-btn" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-6 rounded-lg">OK</button>
        </div>
    </div>
    
    <script type="module">
        // Importa le funzioni di Firebase necessarie
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // --- CONFIGURAZIONE FIREBASE ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "AIza...", authDomain: "...", projectId: "..." };
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
       
        // --- STATO GLOBALE DEL GIOCO (SINCRONIZZATO) ---
        let roomData = null; // L'unica fonte di veritÃ , dal database
        let currentUser = null; // Informazioni sull'utente corrente
        let userNickname = '';
        let currentRoomId = null;
        let roomUnsubscribe = null; // Funzione per smettere di ascoltare i cambiamenti della stanza
        let isActionLocked = false;
        let bombaTimer = null;
        let tickInterval = null;

        const screens = {
            nickname: document.getElementById('nickname-screen'),
            lobby: document.getElementById('lobby-screen'),
            createRoom: document.getElementById('create-room-screen'),
            wait: document.getElementById('room-wait-screen'),
            vote: document.getElementById('game-mode-vote-screen'),
            memory: document.getElementById('memory-game-screen'),
            bomba: document.getElementById('bomba-screen'),
            summaryScreen: document.getElementById('summary-screen'),
            minigameSelection: document.getElementById('minigame-selection-screen'),
        };
        
        // --- SINTETIZZATORE AUDIO ---
        let synth, noiseSynth;
        function setupAudio() {
            if (typeof Tone !== 'undefined' && !synth) {
                try {
                    synth = new Tone.MembraneSynth().toDestination();
                    noiseSynth = new Tone.NoiseSynth({
                        noise: { type: 'white' },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0 }
                    }).toDestination();
                } catch (e) {
                    console.error("Failed to create synths:", e);
                    synth = null;
                    noiseSynth = null;
                }
            }
        }

        // --- FUNZIONI UTILI E RENDER ---
        const modal = document.getElementById('notification-modal');
        const modalMessage = document.getElementById('modal-message');
        document.getElementById('modal-close-btn').addEventListener('click', () => modal.classList.add('hidden'));

        function showModal(message) {
            modalMessage.textContent = message;
            modal.classList.remove('hidden');
        }

        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.add('hidden'));
            if (screens[screenName]) screens[screenName].classList.remove('hidden');
        }
        
        // La funzione renderAll viene chiamata ogni volta che i dati cambiano nel database
        function renderAll() {
            if (!roomData || !currentUser) return; // Non fare nulla se non ci sono dati
            
            switch(roomData.gameState) {
                case 'waiting': showScreen('wait'); updateWaitingRoomUI(); break;
                case 'voting': showScreen('vote'); updateVoteUI(); break;
                case 'in-game':
                    if (roomData.currentGame === 'memory') {
                        showScreen('memory');
                        renderMemoryGame();
                    } else if (roomData.currentGame === 'bomba') {
                        showScreen('bomba');
                        renderBomba();
                    }
                    break;
                case 'round-end':
                case 'championship-finished':
                case 'free-play-finished':
                    showScreen('summaryScreen');
                    renderSummaryScreen();
                    // L'host gestirÃ  l'avanzamento del gioco
                    if(roomData.hostId === currentUser.uid && roomData.gameState === 'round-end') {
                         setTimeout(() => advanceChampionship(), 5000);
                    }
                    break;
                case 'minigame-selection': showScreen('minigameSelection'); renderMinigameSelection(); break;
            }
        }

        // --- FLUSSO PRINCIPALE E GESTIONE EVENTI ---
        document.addEventListener('DOMContentLoaded', () => {
            // Setup sliders
            document.getElementById('player-count-slider').addEventListener('input', (e) => document.getElementById('player-count-value').textContent = e.target.value);
            document.getElementById('cpu-difficulty-slider').addEventListener('input', (e) => document.getElementById('cpu-difficulty-value').textContent = e.target.value);
            document.getElementById('rounds-count-slider').addEventListener('input', (e) => document.getElementById('rounds-count-value').textContent = e.target.value);
        
            // Setup bottoni
            document.getElementById('join-lobby-btn').addEventListener('click', joinLobby);
            document.getElementById('create-room-btn').addEventListener('click', () => showScreen('createRoom'));
            document.getElementById('confirm-create-room-btn').addEventListener('click', createRoom);
            document.getElementById('add-cpu-btn').addEventListener('click', addCpu);
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            document.querySelectorAll('.vote-btn').forEach(btn => btn.addEventListener('click', handleVote));
            document.querySelectorAll('.minigame-btn').forEach(btn => btn.addEventListener('click', startNewMinigame));
            document.getElementById('pass-bomb-btn').addEventListener('click', passBomb);
            document.getElementById('play-again-btn').addEventListener('click', resetToVoting);

             document.getElementById('copy-room-code').addEventListener('click', () => {
                navigator.clipboard.writeText(currentRoomId).then(() => {
                    const feedback = document.getElementById('copy-feedback');
                    feedback.textContent = 'Copiato!';
                    setTimeout(() => feedback.textContent = '', 2000);
                });
            });

            // Gestione autenticazione
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUser = user;
                    console.log("Authenticated with UID:", currentUser.uid);
                    // L'utente Ã¨ loggato, possiamo procedere
                } else {
                     try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                        showModal("Errore di autenticazione. Ricarica la pagina.");
                    }
                }
            });
        });

        async function joinLobby() {
            const input = document.getElementById('nickname-input');
            if (input.value.trim().length > 2) {
                userNickname = input.value.trim();
                
                if (!currentUser) {
                    showModal("Autenticazione in corso, riprova tra un secondo...");
                    return;
                }
                
                if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                    Tone.start().then(setupAudio).catch(e => console.error("Audio could not be started.", e));
                } else {
                    setupAudio();
                }

                showScreen('lobby');
            } else {
                input.classList.add('shake');
                setTimeout(() => input.classList.remove('shake'), 500);
            }
        }

        async function createRoom() {
            const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
            const newRoomData = {
                id: roomId,
                hostId: currentUser.uid,
                players: [{ uid: currentUser.uid, nickname: userNickname, score: 0, isHost: true }],
                maxPlayers: parseInt(document.getElementById('player-count-slider').value),
                gameState: 'waiting',
                cpuDifficulty: parseInt(document.getElementById('cpu-difficulty-slider').value),
                championshipRounds: parseInt(document.getElementById('rounds-count-slider').value),
            };
            
            currentRoomId = roomId;
            const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', roomId);
            await setDoc(roomRef, newRoomData);
            listenToRoom(roomId);
        }
        
        function listenToRoom(roomId) {
             if (roomUnsubscribe) roomUnsubscribe(); // Smetti di ascoltare la stanza precedente
             const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', roomId);
             roomUnsubscribe = onSnapshot(roomRef, (doc) => {
                 if(doc.exists()){
                     roomData = doc.data();
                     renderAll();
                 } else {
                     // La stanza Ã¨ stata cancellata
                     showModal("La stanza non esiste piÃ¹. Torni alla lobby.");
                     showScreen('lobby');
                     roomData = null;
                     currentRoomId = null;
                 }
             });
        }

        function updateWaitingRoomUI() {
            document.getElementById('room-code-display').textContent = currentRoomId;
            document.getElementById('current-players').textContent = roomData.players.length;
            document.getElementById('max-players').textContent = roomData.maxPlayers;

            const playerList = document.getElementById('player-list');
            playerList.innerHTML = '';
            roomData.players.forEach(p => {
                const playerDiv = document.createElement('div');
                playerDiv.className = 'bg-slate-700 p-3 rounded-lg text-center';
                const crown = p.isHost ? 'ðŸ‘‘' : (p.isCPU ? 'ðŸ¤–' : '');
                playerDiv.innerHTML = `<span class="font-bold">${crown} ${p.nickname}</span>`;
                playerList.appendChild(playerDiv);
            });
            
            // Mostra i controlli solo all'host
            const hostControls = document.getElementById('host-controls');
            if (roomData.hostId === currentUser.uid) {
                hostControls.classList.remove('hidden');
                document.getElementById('start-game-btn').disabled = roomData.players.length < 2;
                document.getElementById('add-cpu-btn').disabled = roomData.players.length >= roomData.maxPlayers;
            } else {
                hostControls.classList.add('hidden');
            }
        }
        
        async function addCpu() {
            if (roomData.players.length < roomData.maxPlayers) {
                const cpuCount = roomData.players.filter(p => p.isCPU).length;
                const newCPU = { uid: `cpu_${Date.now()}`, nickname: `CPU ${cpuCount + 1}`, score: 0, isCPU: true };
                
                const updatedPlayers = [...roomData.players, newCPU];
                const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
                await updateDoc(roomRef, { players: updatedPlayers });
            }
        }
        
        async function startGame() {
             const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
             await updateDoc(roomRef, { 
                gameState: 'voting',
                votes: {},
                'players': roomData.players.map(p => ({...p, hasVoted: false})) // Resetta i voti
             });
        }
        
        async function handleVote(e) {
            const vote = e.target.dataset.vote;
            const playerInRoom = roomData.players.find(p => p.uid === currentUser.uid);
            
            if(playerInRoom && !playerInRoom.hasVoted){
                playerInRoom.hasVoted = true;
                
                const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
                const currentVotes = roomData.votes || {};
                const newVoteCount = (currentVotes[vote] || 0) + 1;

                await updateDoc(roomRef, {
                    players: roomData.players, // Invia l'array aggiornato dei giocatori
                   [`votes.${vote}`]: newVoteCount // Usa la dot notation per aggiornare un campo specifico
                });
            }
        }

        async function updateVoteUI() {
            const player = roomData.players.find(p => p.uid === currentUser.uid);
            document.getElementById('vote-feedback').textContent = player.hasVoted ? 'Hai votato. In attesa degli altri...' : '';
            document.getElementById('vote-options').classList.toggle('hidden', player.hasVoted);

            const allVoted = roomData.players.every(p => p.hasVoted || p.isCPU);

            if (allVoted && roomData.hostId === currentUser.uid) {
                const votes = roomData.votes || {};
                // CPU "vota" casualmente
                roomData.players.forEach(p => {
                    if (p.isCPU) {
                        const randomVote = Math.random() < 0.5 ? 'free-play' : 'championship';
                        votes[randomVote] = (votes[randomVote] || 0) + 1;
                    }
                });

                const freePlayVotes = votes['free-play'] || 0;
                const championshipVotes = votes['championship'] || 0;
                const finalGameMode = championshipVotes > freePlayVotes ? 'championship' : 'free-play';
                
                const updates = {};
                updates.gameMode = finalGameMode;

                if (finalGameMode === 'free-play') {
                    updates.gameState = 'minigame-selection';
                } else {
                    updates.gameState = 'in-game';
                    updates.currentGame = 'memory'; // Il campionato inizia sempre con memory
                    updates.currentRound = 1;
                    updates.players = roomData.players.map(p => ({...p, score: 0}));
                    updates.currentPlayerIndex = Math.floor(Math.random() * roomData.players.length);
                    initializeMemoryGame(updates);
                }

                const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
                await updateDoc(roomRef, updates);
            }
        }
        
        async function startNewMinigame(e) {
            if(roomData.hostId !== currentUser.uid) return;

            const minigame = e.target.dataset.minigame;
            const updates = {
                gameState: 'in-game',
                currentGame: minigame,
                gameData: null,
                currentPlayerIndex: Math.floor(Math.random() * roomData.players.length)
            };

            if (roomData.gameMode === 'free-play') {
                updates.players = roomData.players.map(p => ({...p, score: 0}));
            }
            
            if (minigame === 'memory') initializeMemoryGame(updates);
            if (minigame === 'bomba') initializeBomba(updates);
            
            const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
            await updateDoc(roomRef, updates);
        }

        // --- LOGICA MEMORY ---
        function initializeMemoryGame(updates) {
            const playerCount = updates.players.length;
            let cols, rows;
            if (playerCount >= 12) { cols = 8; rows = 6; }
            else if (playerCount >= 8) { cols = 7; rows = 6; }
            else { cols = 6; rows = 6; }
            
            const totalCards = cols * rows;
            if (totalCards % 2 !== 0) { cols -=1; }
            const totalPairs = (cols * rows) / 2;
            const emojis = ['ðŸ•', 'ðŸ”', 'ðŸŸ', 'ðŸŒ­', 'ðŸ¿', 'ðŸ§‚', 'ðŸ¥“', 'ðŸ¥š', 'ðŸ§‡', 'ðŸ¥ž', 'ðŸ§ˆ', 'ðŸž', 'ðŸ¥', 'ðŸ¥¨', 'ðŸ¥¯', 'ðŸ¥–', 'ðŸ§€', 'ðŸ¥—', 'ðŸ¥™', 'ðŸ¥ª', 'ðŸ¥«', 'ðŸ±', 'ðŸ˜', 'ðŸ™', 'ðŸš', 'ðŸ›', 'ðŸœ', 'ðŸ', 'ðŸ ', 'ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¥®', 'ðŸ¡', 'ðŸ¥Ÿ', 'ðŸ¥ ', 'ðŸ¥¡', 'ðŸ¦', 'ðŸ§', 'ðŸ¨', 'ðŸ©', 'ðŸª', 'ðŸŽ‚', 'ðŸ°', 'ðŸ§', 'ðŸ¥§', 'ðŸ«', 'ðŸ¬', 'ðŸ­'];
            
            const shuffledEmojis = [...emojis].sort(() => 0.5 - Math.random());
            const gameEmojis = shuffledEmojis.slice(0, totalPairs);
            
            let cardValues = [...gameEmojis, ...gameEmojis];
            cardValues.sort(() => Math.random() - 0.5);

            const board = cardValues.map((value, index) => ({ id: index, value: value, isFlipped: false, isMatched: false }));

            updates.gameData = { type: 'memory', board, grid: { cols, rows }, flippedCards: [], lastPlayerWhoScored: null };
        }

        function renderMemoryGame() {
            const { gameData, players, currentPlayerIndex, gameMode, currentRound, championshipRounds } = roomData;
            
            if (!gameData || !gameData.board) return; // Dati non ancora pronti
            const { board, grid } = gameData;
            
            document.getElementById('leaderboard-title').textContent = gameMode === 'championship' ? 'Classifica Torneo' : 'Classifica';
            const gameModeDisplay = document.getElementById('game-mode-display');
            if (gameMode === 'championship') gameModeDisplay.textContent = `Campionato - Round ${currentRound}/${championshipRounds}`;
            else gameModeDisplay.textContent = 'Partita Libera';

            const boardElement = document.getElementById('memory-board');
            boardElement.innerHTML = '';
            boardElement.style.gridTemplateColumns = `repeat(${grid.cols}, minmax(0, 1fr))`;

            board.forEach(card => {
                const cardContainer = document.createElement('div');
                cardContainer.className = 'aspect-square card-container';
                const cardEl = document.createElement('div');
                cardEl.className = 'card';
                if (card.isMatched) cardEl.classList.add('matched');
                if (card.isFlipped) cardEl.classList.add('flipped');
                cardEl.dataset.cardId = card.id;
                cardEl.innerHTML = `<div class="back bg-gradient-to-br from-cyan-500 to-blue-600 cursor-pointer shadow-lg"><svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-cyan-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /></svg></div><div class="front bg-slate-200 text-slate-900 text-2xl sm:text-3xl md:text-4xl lg:text-5xl">${card.value}</div>`;
                if (!card.isMatched && !card.isFlipped) cardEl.querySelector('.back').addEventListener('click', () => handleCardClick(card.id));
                cardContainer.appendChild(cardEl);
                boardElement.appendChild(cardContainer);
            });

            const leaderboardElement = document.getElementById('leaderboard');
            leaderboardElement.innerHTML = '';
            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);
            sortedPlayers.forEach(p => {
                const playerDiv = document.createElement('div');
                playerDiv.className = `flex items-center justify-between p-3 rounded-lg transition-all duration-300 ${p.uid === players[currentPlayerIndex].uid ? 'bg-cyan-600 scale-105 shadow-lg' : 'bg-slate-700'}`;
                playerDiv.innerHTML = `<div class="flex items-center gap-3"><span class="text-2xl">${p.isCPU ? 'ðŸ¤–' : 'ðŸ‘¤'}</span><span class="font-semibold">${p.nickname}</span></div><span class="font-bold text-xl text-cyan-400">${p.score}</span>`;
                leaderboardElement.appendChild(playerDiv);
            });

            document.getElementById('current-player-turn').textContent = players[currentPlayerIndex].nickname;
            
            const currentPlayer = players[currentPlayerIndex];
            if (currentPlayer.isCPU && !isActionLocked && roomData.hostId === currentUser.uid) {
                setTimeout(() => runCpuTurnMemory(), 1500);
            }
        }

        async function handleCardClick(cardId) {
            const { players, currentPlayerIndex, gameData } = roomData;
            
            if (isActionLocked || players[currentPlayerIndex].uid !== currentUser.uid || gameData.flippedCards.length >= 2) {
                if(!isActionLocked && players[currentPlayerIndex].uid !== currentUser.uid) {
                    document.getElementById('turn-indicator').classList.add('shake');
                    setTimeout(()=> document.getElementById('turn-indicator').classList.remove('shake'), 500);
                }
                return;
            }
            
            const card = gameData.board.find(c => c.id === cardId);
            if (card.isFlipped || card.isMatched) return;

            isActionLocked = true; // Blocca subito l'azione
            card.isFlipped = true;
            gameData.flippedCards.push(cardId);

            const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
            await updateDoc(roomRef, { gameData: gameData });

            if (gameData.flippedCards.length === 2) {
                setTimeout(() => checkMatch(), 1000);
            } else {
                 isActionLocked = false; // Sblocca se non Ã¨ la seconda carta
            }
        }
        
        // checkMatch deve essere eseguito solo dall'host per evitare race conditions
        async function checkMatch() {
            if (roomData.hostId !== currentUser.uid) return;

            const { players, currentPlayerIndex, gameData, gameMode } = roomData;
            const { board, flippedCards } = gameData;
            
            if (flippedCards.length < 2) {
                isActionLocked = false; return;
            }

            const card1 = board.find(c => c.id === flippedCards[0]);
            const card2 = board.find(c => c.id === flippedCards[1]);
            let nextPlayerIndex = currentPlayerIndex;
            let lastPlayerScored = gameData.lastPlayerWhoScored;
            let newGameState = roomData.gameState;

            if (card1.value === card2.value) {
                card1.isMatched = true;
                card2.isMatched = true;
                
                let points = 1;
                if (gameData.lastPlayerWhoScored === players[currentPlayerIndex].uid) points = 1.5;
                players[currentPlayerIndex].score += points;
                lastPlayerScored = players[currentPlayerIndex].uid;
            } else {
                card1.isFlipped = false;
                card2.isFlipped = false;
                nextPlayerIndex = (currentPlayerIndex + 1) % players.length;
                lastPlayerScored = null;
            }
            
            const isGameOver = board.every(c => c.isMatched);
            
            if (isGameOver) {
                if (gameMode === 'championship') newGameState = 'round-end';
                else newGameState = 'free-play-finished';
            }
            
            const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
            await updateDoc(roomRef, {
                'gameData.board': board,
                'gameData.flippedCards': [],
                'gameData.lastPlayerWhoScored': lastPlayerScored,
                players: players,
                currentPlayerIndex: nextPlayerIndex,
                gameState: newGameState
            });
            isActionLocked = false;
        }

        function runCpuTurnMemory() {
            if (isActionLocked) return;
            isActionLocked = true;

            // Logica CPU... uguale a prima
            const { gameData, cpuDifficulty } = roomData;
            const availableCards = gameData.board.filter(c => !c.isMatched && !c.isFlipped);
            if (availableCards.length < 2) {
                isActionLocked = false; return;
            }
            
            let card1Id, card2Id;
            const memoryPower = cpuDifficulty / 5;
            let foundPair = false;
            if (Math.random() < memoryPower) {
                const cardMap = new Map();
                for (const card of gameData.board.filter(c => !c.isMatched)) {
                    if (cardMap.has(card.value)) {
                        card1Id = cardMap.get(card.value); card2Id = card.id; foundPair = true; break;
                    }
                    cardMap.set(card.value, card.id);
                }
            }

            if (!foundPair) {
                const firstIdx = Math.floor(Math.random() * availableCards.length);
                card1Id = availableCards[firstIdx].id;
                let secondIdx;
                do { secondIdx = Math.floor(Math.random() * availableCards.length); } while (secondIdx === firstIdx);
                card2Id = availableCards[secondIdx].id;
            }
             // Simula i click della CPU
            setTimeout(() => {
                handleCardClick(card1Id).then(() => {
                    setTimeout(() => {
                        handleCardClick(card2Id);
                    }, 800);
                })
            }, 800);
        }

        // --- LOGICA BOMBA ---
        function initializeBomba(updates) {
             updates.players = roomData.players.map(p => ({...p, eliminated: false}));
             updates.gameData = {
                 playerWithBomb: Math.floor(Math.random() * roomData.players.length),
                 activePlayerCount: roomData.players.length,
                 eliminationOrder: [],
             };
             // Non avviare il timer qui, lo farÃ  onSnapshot
        }
        
        function renderBomba() {
            const { players, gameData, gameMode, currentRound, championshipRounds } = roomData;
            const playerCircle = document.getElementById('player-circle');
            playerCircle.innerHTML = '';
            
            const info = document.getElementById('bomba-info');
            if (gameMode === 'championship') info.innerHTML = `<p class="text-lg font-semibold text-purple-400">Campionato - Round ${currentRound}/${championshipRounds}</p>`;
            else info.innerHTML = `<p class="text-lg font-semibold text-purple-400">Partita Libera</p>`;

            const radius = playerCircle.offsetWidth / 2.8;
            const angleStep = 360 / players.length;
            players.forEach((p, index) => {
                const angle = angleStep * index - 90;
                const x = radius * Math.cos(angle * Math.PI / 180);
                const y = radius * Math.sin(angle * Math.PI / 180);

                const item = document.createElement('div');
                item.className = 'player-circle-item absolute w-20 h-20 sm:w-28 sm:h-28 flex flex-col items-center justify-center';
                item.style.left = `calc(50% + ${x}px)`;
                item.style.top = `calc(50% + ${y}px)`;
                item.style.transform = 'translate(-50%, -50%)';
                if (p.eliminated) item.classList.add('eliminated');

                const hasBomb = index === gameData.playerWithBomb;
                const ringColor = hasBomb ? 'ring-4 ring-red-500' : '';
                item.innerHTML = `
                    <div class="w-14 h-14 sm:w-20 sm:h-20 rounded-full flex items-center justify-center bg-slate-700 ${ringColor} transition-all text-4xl">${p.isCPU ? 'ðŸ¤–' : 'ðŸ‘¤'}</div>
                    <p class="font-bold text-xs sm:text-base mt-1 text-center bg-black bg-opacity-50 px-1 rounded">${p.nickname}</p>
                `;
                playerCircle.appendChild(item);
            });

            const bombContainer = document.createElement('div');
            bombContainer.className = 'bomb-container';
            bombContainer.innerHTML = `
                <div id="bomb-timer-ring" class="bomb-timer-ring"></div>
                <div id="bomb" class="bomb text-7xl sm:text-9xl">ðŸ’£</div>
            `;
            playerCircle.appendChild(bombContainer);

            const currentPlayerWithBomb = players[gameData.playerWithBomb];
            const passBtn = document.getElementById('pass-bomb-btn');
            passBtn.classList.toggle('hidden', currentPlayerWithBomb.uid !== currentUser.uid || isActionLocked);
        }

        async function passBomb() {
            if (isActionLocked) return;
            
            const { players, gameData } = roomData;
            let nextPlayerIndex = (gameData.playerWithBomb + 1) % players.length;
            while(players[nextPlayerIndex].eliminated) {
                nextPlayerIndex = (nextPlayerIndex + 1) % players.length;
            }
            
            const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
            await updateDoc(roomRef, {
                'gameData.playerWithBomb': nextPlayerIndex,
                 // L'host avvierÃ  il nuovo timer quando riceve l'update
            });
        }
        
        // La logica del timer e della CPU Bomba deve essere gestita solo dall'host
        function manageBombaHostLogic() {
            if (roomData.gameState !== 'in-game' || roomData.currentGame !== 'bomba' || roomData.hostId !== currentUser.uid) {
                clearTimeout(bombaTimer);
                clearInterval(tickInterval);
                return;
            }
            
            // Se non c'Ã¨ un timer attivo, ne avvia uno nuovo
            if (!roomData.gameData.bombTimerEnd) {
                const bombDuration = (Math.random() * 10 + 5) * 1000; // 5-15 secondi
                const bombTimerEnd = Date.now() + bombDuration;
                const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
                updateDoc(roomRef, {'gameData.bombTimerEnd': bombTimerEnd});
                return; // Aspetta che l'update si propaghi
            }

             // Anima la bomba
            const { bombTimerEnd } = roomData.gameData;
            const timeLeft = bombTimerEnd - Date.now();
            const bombDuration = 10000; // Usa una durata media per l'animazione
            const progress = 1 - (timeLeft / bombDuration);
            const bombEl = document.getElementById('bomb');
            const timerRing = document.getElementById('bomb-timer-ring');
            
            if (bombEl && timerRing) {
                if(progress < 0.3) { bombEl.className = 'bomb text-7xl sm:text-9xl'; timerRing.style.borderColor = '#67e8f9'; }
                else if (progress < 0.6) { bombEl.className = 'bomb text-7xl sm:text-9xl bomb-unstable-1'; timerRing.style.borderColor = '#fef08a'; } 
                else if (progress < 0.8) { bombEl.className = 'bomb text-7xl sm:text-9xl bomb-unstable-2'; timerRing.style.borderColor = '#fb923c'; }
                else { bombEl.className = 'bomb text-7xl sm:text-9xl bomb-unstable-3'; timerRing.style.borderColor = '#ef4444'; }
            }

            // Controlla l'esplosione
            if (timeLeft <= 0) {
                handleExplosion();
            }

            // Gestisci il turno della CPU
            const currentPlayer = roomData.players[roomData.gameData.playerWithBomb];
            if (currentPlayer.isCPU && !isActionLocked) {
                runCpuTurnBomba();
            }
        }
        
        let bombaHostInterval;
        onSnapshot(doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId || 'dummy'), (doc) => {
            if (doc.exists()) {
                const data = doc.data();
                if (data.gameState === 'in-game' && data.currentGame === 'bomba' && data.hostId === currentUser.uid) {
                    if (!bombaHostInterval) bombaHostInterval = setInterval(manageBombaHostLogic, 100);
                } else {
                    clearInterval(bombaHostInterval);
                    bombaHostInterval = null;
                }
            } else {
                 clearInterval(bombaHostInterval);
                 bombaHostInterval = null;
            }
        });


        async function handleExplosion() {
            if (isActionLocked) return;
            isActionLocked = true;
            if (noiseSynth) noiseSynth.triggerAttackRelease('0.5');

            const { players, gameData, gameMode } = roomData;
            const explodedPlayer = players[gameData.playerWithBomb];
            explodedPlayer.eliminated = true;
            gameData.eliminationOrder.push(explodedPlayer.uid);
            const activePlayerCount = gameData.activePlayerCount - 1;
            
            let newGameState = roomData.gameState;
            let nextPlayerIndex = gameData.playerWithBomb;
            
            if (activePlayerCount <= 1) {
                const winner = players.find(p => !p.eliminated);
                if(winner) gameData.eliminationOrder.push(winner.uid);
                
                const totalPlayers = players.length;
                gameData.eliminationOrder.reverse().forEach((playerId, index) => {
                    const player = players.find(p => p.uid === playerId);
                    if(player) player.score += (totalPlayers - index);
                });

                newGameState = (gameMode === 'championship') ? 'round-end' : 'free-play-finished';
            } else {
                nextPlayerIndex = (gameData.playerWithBomb + 1) % players.length;
                while(players[nextPlayerIndex].eliminated) {
                    nextPlayerIndex = (nextPlayerIndex + 1) % players.length;
                }
            }

            const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
             await updateDoc(roomRef, {
                 gameState: newGameState,
                 players: players,
                 'gameData.playerWithBomb': nextPlayerIndex,
                 'gameData.activePlayerCount': activePlayerCount,
                 'gameData.eliminationOrder': gameData.eliminationOrder,
                 'gameData.bombTimerEnd': null // Resetta il timer
             });
             isActionLocked = false;
        }

         function runCpuTurnBomba() {
            if (isActionLocked) return;
            isActionLocked = true;
            
            const waitTime = (Math.random() * (5 - roomData.cpuDifficulty) + 1) * 1000;
            
            setTimeout(async () => {
                // Ricontrolla lo stato prima di agire
                if (roomData.players[roomData.gameData.playerWithBomb]?.isCPU) {
                     await passBomb();
                }
                isActionLocked = false;
            }, waitTime);
        }
        
        // --- GESTIONE FINE PARTITA E CAMPIONATO ---
        function renderSummaryScreen() {
            const { players, gameState, currentRound, championshipRounds, hostId } = roomData;
            const title = document.getElementById('summary-title');
            const subtitle = document.getElementById('summary-subtitle');
            const leaderboard = document.getElementById('summary-leaderboard');
            leaderboard.innerHTML = '';
            const sortedPlayers = [...players].sort((a, b) => b.score - a.score);

            if (gameState === 'championship-finished') {
                title.textContent = 'ðŸ† Campionato Finito! ðŸ†';
                subtitle.textContent = `Il vincitore Ã¨ ${sortedPlayers[0].nickname}!`;
            } else if (gameState === 'round-end') {
                title.textContent = `Fine del Round ${currentRound}`;
                subtitle.textContent = `Prossimo round tra 5 secondi...`;
            } else if (gameState === 'free-play-finished') {
                title.textContent = 'ðŸŽ‰ Partita Finita! ðŸŽ‰';
                subtitle.textContent = `L'host sceglierÃ  il prossimo gioco.`;
            }
            
            sortedPlayers.forEach((p, index) => {
                const playerDiv = document.createElement('div');
                const rankIcon = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][index] || 'ðŸ”¹';
                playerDiv.className = 'flex items-center justify-between p-4 rounded-lg bg-slate-700';
                playerDiv.innerHTML = `
                    <div class="flex items-center gap-4">
                        <span class="text-3xl">${rankIcon}</span>
                        <span class="font-semibold text-xl">${p.nickname} ${p.isCPU ? 'ðŸ¤–' : ''}</span>
                    </div>
                    <span class="font-bold text-2xl text-cyan-400">${p.score}</span>`;
                leaderboard.appendChild(playerDiv);
            });

            const playAgainBtn = document.getElementById('play-again-btn');
            if (hostId === currentUser.uid && (gameState === 'championship-finished' || gameState === 'free-play-finished')) {
                 playAgainBtn.classList.remove('hidden');
            } else {
                 playAgainBtn.classList.add('hidden');
            }
        }
        
        async function advanceChampionship() {
            if(roomData.hostId !== currentUser.uid) return;

            const nextRound = roomData.currentRound + 1;
            const updates = {};

            if (nextRound > roomData.championshipRounds) {
                updates.gameState = 'championship-finished';
            } else {
                updates.gameState = 'in-game';
                updates.currentRound = nextRound;
                const games = ['memory', 'bomba'];
                updates.currentGame = games[Math.floor(Math.random() * games.length)];
                updates.gameData = null;
                updates.currentPlayerIndex = Math.floor(Math.random() * roomData.players.length);
                if (updates.currentGame === 'memory') initializeMemoryGame(updates);
                if (updates.currentGame === 'bomba') initializeBomba(updates);
            }
            
            const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
            await updateDoc(roomRef, updates);
        }

        function renderMinigameSelection() {
            const isHost = roomData.hostId === currentUser.uid;
            document.getElementById('minigame-options').classList.toggle('hidden', !isHost);
            document.getElementById('minigame-selection-wait-msg').classList.toggle('hidden', isHost);
            document.querySelector('#minigame-selection-screen h2').textContent = isHost ? 'Scegli un Minigioco' : 'Selezione Minigioco';
        }

        async function resetToVoting() {
             if (roomData.hostId !== currentUser.uid) return;
             // Riporta alla votazione per giocare di nuovo
             const roomRef = doc(db, 'artifacts', appId, 'public/data/rooms', currentRoomId);
             await updateDoc(roomRef, { 
                gameState: 'voting',
                votes: {},
                gameMode: null,
                currentGame: null,
                gameData: null,
                players: roomData.players.map(p => ({...p, hasVoted: false, score: 0, eliminated: false}))
             });
        }
    </script>
</body>
</html>
